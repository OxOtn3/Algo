# 基数排序

# 平均时间复杂度：O(d * (n + k))，必须是非负整数，且maxV和minV差距尽可能小
# 最好时间复杂度：O(d * (n + k))
# 最坏时间复杂度：O(d * (n + k))

# 空间复杂度：O(n + k)

# 稳定性：稳定

# 思路

# 是一种非比较排序算法，时间复杂度是 O(n) 。它的主要思路是，
# 1. 将所有待排序整数（注意，必须是非负整数）统一为位数相同的整数，位数较少的前面补零。一般用10进制，
# 也可以用16进制甚至2进制。所以前提是能够找到最大值，得到最长的位数，设 k 进制下最长为位数为 d 。
# 3. 从最低位开始，依次进行一次 稳定排序 。这样从最低位一直到最高位排序完成以后，整个序列就变成了一个有序序列。
# 举个例子，有一个整数序列，0, 123, 45, 386, 106，下面是排序过程：
# 第一次排序，个位，000 123 045 386 106，无任何变化
# 第二次排序，十位，000 106 123 045 386
# 三次排序，百位，000 045 106 123 386
# 最终结果，0, 45, 106, 123, 386, 排序完成。

def radix_sort(array):
    max_num = max(array)
    place = 1
    while max_num >= 10**place:
        place += 1
    for i in range(place):
        buckets = [[] for _ in range(10)]
        for num in array:
            radix = int(num / (10**i) % 10)
            buckets[radix].append(num)
        j = 0
        for k in range(10):
            for num in buckets[k]:
                array[j] = num
                j += 1
    return array


# 为什么同一数位的排序子程序要用稳定排序？因为稳定排序能将上一次排序的成果保留下来。
# 例如十位数的排序过程能保留个位数的排序成果，百位数的排序过程能保留十位数的排序成果。

# 能不能用2进制？能，可以把待排序序列中的每个整数都看成是01组成的二进制数值。
# 那这样的话，岂不是任意一个非负整数序列都可以用基数排序算法？
# 理论上是的，假设待排序序列中最大整数为2 4 . 1，则最大位数 d=64 ，时间复杂度为 O(64n) 。
# 可见任意一个非负整数序列都可以在线性时间内完成排序。
# 既然任意一个非负整数序列都可以在线性时间内完成排序，那么基于比较排序的算法有什么意义呢？
# 基于比较的排序算法，时间复杂度是 O(nlogn) ，看起来比 O(64n) 慢，仔细一想，其实不是， O(nlogn) 只有当序列非常长，
# 达到2^64 个元素的时候，才会与 O(64n) 相等，因此，64这个常数系数太大了，
# 大部分时候， n 远远小于2^64，基于比较的排序算法还是比 O(64n) 快的。
# 当使用2进制时， k=2 最小，位数 d 最大，时间复杂度 O(nd) 会变大，空间复杂度 O(n+k) 会变小。
# 当用最大值作为基数时， k=maxV 最大， d=1 最小，此时时间复杂度 O(nd) 变小，
# 但是空间复杂度 O(n+k) 会急剧增大，此时基数排序退化成了计数排序。

# 基数排序也是一种桶排序。桶排序是按值区间划分桶，基数排序是按数位来划分；基数排序可以看做是多轮桶排序，每个数位上都进行一轮桶排序。